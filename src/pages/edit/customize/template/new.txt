import { TPrintTemplate } from '@/utils/types/global'
import { TemplateFrame } from './TemplateFrame'
import type React from 'react'
import { cn } from '@/configs/ui/tailwind-utils'
import { styleToFramesDisplayerByTemplateType } from '@/configs/print-template/templates-helpers'
import { useEffect, useRef, useState } from 'react'

type TFramesDisplayerProps = {
  template: TPrintTemplate
} & Partial<{
  plusIconReplacer?: React.JSX.Element
  frameStyles: Partial<{
    container: React.CSSProperties
    plusIconWrapper: React.CSSProperties
  }>
  frameClassNames: Partial<{
    container: string
    plusIconWrapper: string
  }>
  displayerClassNames: {
    container: string
  }
  onClickFrame: (e: React.MouseEvent<HTMLDivElement, MouseEvent>, frameId: string) => void
  displayScrollButton: boolean
}>

type TFrameBounds = {
  min: number // offsetY nhỏ nhất (kéo lên)
  max: number // offsetY lớn nhất (kéo xuống)
}

export const FramesDisplayer = ({
  template,
  plusIconReplacer,
  frameStyles,
  frameClassNames,
  displayerClassNames,
  onClickFrame,
  displayScrollButton = false,
}: TFramesDisplayerProps) => {
  const { frames, type } = template
  const [offsetY, setOffsetY] = useState(0) // margin-top động
  const [dragging, setDragging] = useState(false)
  const startYRef = useRef(0)
  const startOffsetRef = useRef(0)

  const [framesBounds, setFramesBounds] = useState<Record<string, TFrameBounds>>({})

  const handleImageBoundsChange = (frameId: string, bounds: TFrameBounds) => {
    setFramesBounds((prev) => ({
      ...prev,
      [frameId]: bounds,
    }))
  }

  // hàm clamp offsetY theo tất cả frames
  const clampOffset = (value: number) => {
    const allBounds = Object.values(framesBounds)
    if (!allBounds.length) return value

    // giao nhau của các khoảng [min, max]
    const min = Math.max(...allBounds.map((b) => b.min))
    const max = Math.min(...allBounds.map((b) => b.max))

    if (min > max) return value // nếu config sai, thôi kệ :v

    if (value < min) return min
    if (value > max) return max
    return value
  }

  const handleMouseDown = (e: React.MouseEvent) => {
    setDragging(true)
    startYRef.current = e.clientY
    startOffsetRef.current = offsetY
  }

  const displayerRef = useRef<HTMLDivElement | null>(null)
  const listChildRef = useRef<Array<HTMLDivElement | null>>([])

  const registerChild = (index: number, el: HTMLImageElement | null) => {
    listChildRef.current[index] = el
  }

  useEffect(() => {
    if (!dragging) return
    const rootE = displayerRef.current
    const childE = listChildRef.current[0]
    if (rootE && childE) {
      const posRootE = rootE.getBoundingClientRect()
      const posChildE = childE.getBoundingClientRect()
      const y = posChildE.top - posRootE.top
      console.log(y)
    }
  }, [offsetY, dragging, listChildRef, displayerRef])

  const handleCanMove = () => {
    const parent = displayerRef.current
    if (!parent) return true // không có parent => coi như ok

    const parentRect = parent.getBoundingClientRect()

    for (const child of listChildRef.current) {
      if (!child) continue

      const childRect = child.getBoundingClientRect()

      const topDiff = childRect.top - parentRect.top
      const bottomDiff = childRect.bottom - parentRect.bottom

      // Vượt qua top cha
      if (topDiff < 10) {
        return false
      }

      // Vượt qua bottom cha
      if (bottomDiff > -10) {
        return false
      }
    }

    return true // tất cả đều hợp lệ → được move
  }

  const directionRef = useRef<'up' | 'down'>('up')

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!dragging) return
      const delta = e.clientY - startYRef.current
      const next = startOffsetRef.current + delta
      const direction = delta > 0 ? 'down' : 'up'

      if (!handleCanMove() && directionRef.current === direction) return
      directionRef.current = direction
      setOffsetY((prev) => clampOffset(next))
    }

    const handleMouseUp = () => {
      if (!dragging) return
      setDragging(false)
    }

    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)
    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [dragging, framesBounds])

  return (
    <div
      ref={displayerRef}
      className={cn(
        'relative NAME-frames-displayer bg-gray-600/30 p-0.5 max-h-full max-w-full',
        displayerClassNames?.container
      )}
      style={{ ...styleToFramesDisplayerByTemplateType(type) }}
    >
      <div ref={displayerRef} className="relative h-full w-full" style={{ marginTop: offsetY }}>
        {displayScrollButton && (
          <button
            type="button"
            className="absolute -left-8 top-1/2 -translate-y-1/2 cursor-row-resize select-none"
            onMouseDown={handleMouseDown}
          >
            <svg
              className="shadow-lg"
              xmlns="http://www.w3.org/2000/svg"
              width="32"
              height="32"
              viewBox="-9 0 32 32"
            >
              <path
                fill="#fff"
                fill-rule="evenodd"
                d="M12 24H9V8h3c.643 0 1.293.02 1.687-.38.393-.39.393-1.02 0-1.42L7.747.28A.968.968 0 0 0 6.984 0a.968.968 0 0 0-.762.28L.283 6.2c-.393.4-.393 1.03 0 1.42C.676 8.02 1.294 8 2 8h3v16H2c-.643 0-1.324-.02-1.717.38a1.002 1.002 0 0 0 0 1.42l5.939 5.92c.21.21.488.3.762.28.275.02.553-.07.763-.28l5.94-5.92c.393-.4.393-1.03 0-1.42-.394-.4-.95-.38-1.687-.38"
              />
            </svg>
          </button>
        )}
        {frames.map((frame, idx) => (
          <TemplateFrame
            key={frame.id}
            templateFrame={frame}
            templateType={type}
            plusIconReplacer={plusIconReplacer}
            styles={frameStyles}
            classNames={frameClassNames}
            onClickFrame={onClickFrame}
            globalOffsetY={offsetY}
            onImageBoundsChange={handleImageBoundsChange}
            registerChild={registerChild}
            childIndex={idx}
          />
        ))}
      </div>
    </div>
  )
}
